// electron/gcode/core/GCodeParser.ts

import { GCodeCommand, ParsedGCode, GCodeMetadata } from '../types/gcode.types'

export class GCodeParser {
  private lines: string[] = []
  private commands: GCodeCommand[] = []
  private metadata: GCodeMetadata = {}

  /**
   * Parse G-code content into structured format
   */
  parse(content: string): ParsedGCode {
    this.lines = content.split('\n')
    this.commands = []
    this.metadata = {}

    // Parse each line
    this.lines.forEach((line, index) => {
      const command = this.parseLine(line, index)
      if (command) {
        this.commands.push(command)
        this.extractMetadata(command)
      }
    })

    return {
      commands: this.commands,
      metadata: this.metadata,
      raw: this.lines
    }
  }

  /**
   * Parse a single line of G-code
   */
  private parseLine(line: string, lineNumber: number): GCodeCommand | null {
    const trimmed = line.trim()
    if (!trimmed) return null

    const command: GCodeCommand = {
      lineNumber,
      raw: line,
      parameters: new Map(),
      isComment: false
    }

    // Check if it's a pure comment
    if (trimmed.startsWith(';')) {
      command.isComment = true
      command.comment = trimmed.substring(1).trim()
      return command
    }

    // Split by comment
    const commentIndex = trimmed.indexOf(';')
    const codePart = commentIndex >= 0 ? trimmed.substring(0, commentIndex).trim() : trimmed
    const commentPart = commentIndex >= 0 ? trimmed.substring(commentIndex + 1).trim() : undefined

    if (commentPart) {
      command.comment = commentPart
    }

    // Parse the code part
    if (codePart) {
      const tokens = codePart.split(/\s+/)

      // First token is usually the command
      if (tokens.length > 0) {
        const firstToken = tokens[0]
        if (/^[GMT]\d+/.test(firstToken)) {
          command.command = firstToken

          // Parse parameters
          for (let i = 1; i < tokens.length; i++) {
            const token = tokens[i]
            const paramMatch = token.match(/^([A-Z])(.+)$/)
            if (paramMatch) {
              const [, param, value] = paramMatch
              const numValue = parseFloat(value)
              command.parameters.set(param, isNaN(numValue) ? value : numValue)
            }
          }
        } else if (/^[A-Z]\d+/.test(firstToken)) {
          // Some commands start with other letters (like M commands)
          command.command = firstToken

          // Parse remaining parameters
          for (let i = 1; i < tokens.length; i++) {
            const token = tokens[i]
            if (/^[A-Z]/.test(token)) {
              const param = token[0]
              const value = token.substring(1)
              const numValue = parseFloat(value)
              command.parameters.set(param, isNaN(numValue) ? value : numValue)
            }
          }
        }
      }
    }

    return command
  }

  /**
   * Extract metadata from commands
   */
  private extractMetadata(command: GCodeCommand): void {
    // Extract from comments
    if (command.comment) {
      // Generator detection
      if (command.comment.includes('generated by')) {
        const match = command.comment.match(/generated by (.+)/i)
        if (match) {
          this.metadata.generator = match[1].trim()
        }
      }

      // Printer model detection
      if (command.comment.includes('printer_model')) {
        const match = command.comment.match(/printer_model\s*=\s*(.+)/i)
        if (match) {
          this.metadata.printerModel = match[1].trim()
        }
      }

      // Layer height
      if (command.comment.includes('layer_height')) {
        const match = command.comment.match(/layer_height\s*=\s*([\d.]+)/i)
        if (match) {
          this.metadata.layerHeight = parseFloat(match[1])
        }
      }

      // Nozzle diameter
      if (command.comment.includes('nozzle_diameter')) {
        const match = command.comment.match(/nozzle_diameter\s*=\s*([\d.]+)/i)
        if (match) {
          this.metadata.nozzleDiameter = parseFloat(match[1])
        }
      }
    }

    // Tool changes
    if (command.command?.startsWith('T') && command.command.length > 1) {
      // This is now handled by the GCodeInjector
    }
  }

  /**
   * Get current position at a given line
   */
  private getCurrentPosition(lineNumber: number): { x: number; y: number; z: number } {
    let x = 0,
      y = 0,
      z = 0

    for (let i = 0; i < lineNumber && i < this.commands.length; i++) {
      const cmd = this.commands[i]
      if (cmd.command === 'G0' || cmd.command === 'G1') {
        if (cmd.parameters.has('X')) x = cmd.parameters.get('X') as number
        if (cmd.parameters.has('Y')) y = cmd.parameters.get('Y') as number
        if (cmd.parameters.has('Z')) z = cmd.parameters.get('Z') as number
      }
    }

    return { x, y, z }
  }

  /**
   * Find commands by type
   */
  findCommands(commandType: string | RegExp): GCodeCommand[] {
    return this.commands.filter((cmd) => {
      if (!cmd.command) return false
      if (typeof commandType === 'string') {
        return cmd.command === commandType
      }
      return commandType.test(cmd.command)
    })
  }

  /**
   * Get command at specific line
   */
  getCommandAtLine(lineNumber: number): GCodeCommand | undefined {
    return this.commands.find((cmd) => cmd.lineNumber === lineNumber)
  }
}
